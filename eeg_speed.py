# -*- coding: utf-8 -*-
"""EEG_speed.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qkxGHLcWjIcs0qjHOOMBcI692Vw3_Dqt

# **EEG-Based Speed Modulation with Dynamical Systems**
κ
EEG
​
 (x)=α
min
​
 +s(x)⋅(α
max
​
 −α
min
​
 )

 x  mod
​
 =[α
min
​
 +s(x)⋅(α
max
​
 −α
min
​
 )]⋅f(x)


s(x): EEG-derived scalar input (e.g. attention level, intention) # EEG input
s∈[0,1]


α
min
​
 ,α
max
​
 : Lower and upper bounds for speed scaling

 (adding info about robot lower and upper bounds; it should fit for robot's speed limit)
"""

# version Google Colab용 설정
!pip install -q matplotlib==3.5.3

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

"""# **SET UP**

"""

# EEG input random 입력 시퀀스 (random: range 0-1, 50개)
np.random.seed(42)
eeg = np.random.rand(50)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

# Assuming 'eeg' is already defined as in the previous code

# Set up the figure and axes
fig, ax = plt.subplots(figsize=(10, 6))
ax.set_xlabel("Time")
ax.set_ylabel("EEG Signal")
ax.set_title("EEG Data Analysis")

# Create the line plot
line, = ax.plot([], [], lw=2)

# Define the initialization function
def init():
    line.set_data([], [])
    return line,

# Define the animation function
def animate(i):
    x = np.arange(i + 1)
    y = eeg[:i+1]  # Use the EEG data
    line.set_data(x, y)
    ax.set_xlim(0, len(eeg))  # Dynamically adjust x-axis limits
    ax.set_ylim(0, 1)        # Adjust y-axis limits as needed
    return line,

# Create the animation
ani = animation.FuncAnimation(fig, animate, init_func=init, frames=len(eeg), interval=50, blit=True)

# Display the animation (in Colab)
HTML(ani.to_jshtml())

"""# SET UP GOAL

"""

# 목표점 (Cartesian Space)
goal = np.array([-1.5, 1])

# 로봇팔 파라미터
L1 = 1.0
L2 = 1.0

# 속도 게인 함수
#κ EEG​(x)= α min​+s(x)⋅(α max​−α min​)
def get_speed_gain(eeg_val, alpha_min=0.1, alpha_max=2.0):
    return alpha_min + eeg_val * (alpha_max - alpha_min)

# 포워드 키네매틱스 forward
def fk(t1, t2):
    x1 = L1 * np.cos(t1)
    y1 = L1 * np.sin(t1)
    x2 = x1 + L2 * np.cos(t1 + t2)
    y2 = y1 + L2 * np.sin(t1 + t2)
    return np.array([x1, y1]), np.array([x2, y2])

# 역기구학(Initial guess keep updating)
def inverse_kinematics(x, y, prev_theta):
    l = np.sqrt(x**2 + y**2)
    if l > L1 + L2:
        x = x / l * (L1 + L2)
        y = y / l * (L1 + L2)
    c2 = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)
    c2 = np.clip(c2, -1.0, 1.0)
    s2 = np.sqrt(1 - c2**2)
    theta2 = np.arctan2(s2, c2)
    k1 = L1 + L2 * c2
    k2 = L2 * s2
    theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)
    return np.array([theta1, theta2])

# DS based attractor: f(x) = -lambda*(x - x_goal)
def ds_velocity(x, goal, lam=1.0):
    return -lam * (x - goal)

# 시뮬레이션 초기화 simulation
dt = 0.05
theta = np.array([0.1, 0.1])
theta_list = []
ee_list = []
speed_list = []

for i in range(len(eeg)):
    gain = get_speed_gain(eeg[i])
    p1, p2 = fk(theta[0], theta[1])
    x = p2  # 현재 EE 위치 current EE poisition
    v = ds_velocity(x, goal)
    v_mod = gain * v

    # 오일러 통합으로 새로운 위치 추정
    x_next = x + v_mod * dt
    theta = inverse_kinematics(x_next[0], x_next[1], theta)

    theta_list.append(theta.copy())
    ee_list.append(x.copy())
    speed_list.append(np.linalg.norm(v_mod))

# --------------------------
# 애니메이션 설정 (animation setting)
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
ax1.set_xlim(-2, 2)
ax1.set_ylim(-2, 2)
ax1.set_aspect('equal')
ax1.set_title("EEG-Modulated Robot Arm")
ax1.plot(goal[0], goal[1], 'rx', markersize=10, label='Goal')

# 원래 속도 speed 시각화 (좌측 y축)
ax2.set_xlim(0, len(speed_list))
ax2.set_ylim(0, max(speed_list) + 0.5)
ax2.set_title("EEG-based Speed and Input")
ax2.set_ylabel("Speed", color='r')
speed_line, = ax2.plot([], [], 'r-', label='Speed')

# EEG input 입력값 시각화 (우측 y축)
ax2_eeg = ax2.twinx()
ax2_eeg.set_ylim(0, 1.1)
ax2_eeg.set_ylabel("EEG input (s)", color='b')
eeg_line, = ax2_eeg.plot([], [], 'b--', label='EEG Input')

# 로봇 링크 및 궤적
link1, = ax1.plot([], [], 'bo-', lw=3)
link2, = ax1.plot([], [], 'go-', lw=3)
trail, = ax1.plot([], [], 'k--', alpha=0.3)
x_trail, y_trail = [], []

def animate(i):
    t1, t2 = theta_list[i]
    p1, p2 = fk(t1, t2)

    link1.set_data([0, p1[0]], [0, p1[1]])
    link2.set_data([p1[0], p2[0]], [p1[1], p2[1]])

    x_trail.append(p2[0])
    y_trail.append(p2[1])
    trail.set_data(x_trail, y_trail)

    speed_line.set_data(range(i+1), speed_list[:i+1])
    eeg_line.set_data(range(i+1), eeg[:i+1])

    return link1, link2, trail, speed_line, eeg_line

ani = animation.FuncAnimation(fig, animate, frames=len(theta_list), interval=70, blit=True)

HTML(ani.to_jshtml())

from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

# EEG와 속도 리스트

X = eeg.reshape(-1, 1)
y = np.array(speed_list)

# 다항 회귀 (degree=2 예시)
poly = PolynomialFeatures(degree=2)
X_poly = poly.fit_transform(X)
model = LinearRegression()
model.fit(X_poly, y)

# 예측 및 시각화
x_range = np.linspace(0, 1, 100).reshape(-1, 1)
x_poly_range = poly.transform(x_range)
y_pred = model.predict(x_poly_range)

plt.scatter(eeg, speed_list, label="Data")
plt.plot(x_range, y_pred, 'r--', label="Fitted k(x)")
plt.xlabel("EEG value")
plt.ylabel("Speed")
plt.title("Estimated k(x) using Polynomial Regression")
plt.legend()
plt.grid()
plt.show()

"""# 2 goal set up

"""

def get_speed_gain_2nd(eeg_val, alpha_min=0.3, alpha_max=2.0):
    return alpha_min + eeg_val * (alpha_max - alpha_min)

# ---------------------
# 로봇팔  robot arm len
L1 = 1.0
L2 = 1.0

# 목표점들 Goals (2 goal)
goals = [np.array([-1.5, 1]), np.array([1.5, -1.5])]

# EEG 입력 시퀀스
np.random.seed(42)
eeg = np.random.rand(100)  # 총 100 프레임
eeg_chunks = np.array_split(eeg, len(goals))  # 목표점 개수만큼 나눔 each goal need at least 50 EEG in this case

# 결과 저장 리스트
theta_list = []
ee_list = []
speed_list = []
eeg_list = []

# 초기 조건
dt = 0.05
theta = np.array([0.1, 0.1])

# ---------------------
# 시뮬레이션 반복: goal마다
for goal, eeg_seq in zip(goals, eeg_chunks):
    for eeg_val in eeg_seq:
        gain = get_speed_gain_2nd(eeg_val)
        p1, p2 = fk(theta[0], theta[1])
        x = p2
        v = ds_velocity(x, goal)
        v_mod = gain * v

        x_next = x + v_mod * dt
        theta = inverse_kinematics(x_next[0], x_next[1], theta)

        theta_list.append(theta.copy())
        ee_list.append(x.copy())
        speed_list.append(np.linalg.norm(v_mod))
        eeg_list.append(eeg_val)
# --------------------------
# 애니메이션 설정 (animation setting)
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
ax1.set_xlim(-2, 2)
ax1.set_ylim(-2, 2)
ax1.set_aspect('equal')
ax1.set_title("EEG-Modulated Robot Arm to Two Goals")
for g in goals:
    ax1.plot(g[0], g[1], 'rx', markersize=10, label='Goal')

# 원래 속도 speed 시각화 (좌측 y축)
ax2.set_xlim(0, len(speed_list))
eeg_line.set_data(range(len(eeg_list)), eeg_list)
# ax2.set_xlim(0, len(speed_list))
ax2.set_ylim(0, max(speed_list) + 0.5)
ax2.set_title("EEG-based Speed and Input")
ax2.set_ylabel("Speed", color='r')
speed_line, = ax2.plot([], [], 'r-', label='Speed')

# EEG input 입력값 시각화 (우측 y축)
ax2_eeg = ax2.twinx()
ax2_eeg.set_ylim(0, 1.1)
ax2_eeg.set_ylabel("EEG input (s)", color='b')
eeg_line, = ax2_eeg.plot([], [], 'b--', label='EEG Input')

# 로봇 링크 및 궤적
link1, = ax1.plot([], [], 'bo-', lw=3)
link2, = ax1.plot([], [], 'go-', lw=3)
trail, = ax1.plot([], [], 'k--', alpha=0.3)
x_trail, y_trail = [], []

def animate(i):
    t1, t2 = theta_list[i]
    p1, p2 = fk(t1, t2)

    link1.set_data([0, p1[0]], [0, p1[1]])
    link2.set_data([p1[0], p2[0]], [p1[1], p2[1]])

    x_trail.append(p2[0])
    y_trail.append(p2[1])
    trail.set_data(x_trail, y_trail)

    speed_line.set_data(range(i+1), speed_list[:i+1])
    eeg_line.set_data(range(i+1), eeg[:i+1])

    return link1, link2, trail, speed_line, eeg_line

ani = animation.FuncAnimation(fig, animate, frames=len(theta_list), interval=70, blit=True)

HTML(ani.to_jshtml())

from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

# EEG와 속도 리스트

X = eeg.reshape(-1, 1)
y = np.array(speed_list)

# 다항 회귀 (degree=2 예시)
poly = PolynomialFeatures(degree=2)
X_poly = poly.fit_transform(X)
model = LinearRegression()
model.fit(X_poly, y)

# 예측 및 시각화
x_range = np.linspace(0, 1, 100).reshape(-1, 1)
x_poly_range = poly.transform(x_range)
y_pred = model.predict(x_poly_range)

plt.scatter(eeg, speed_list, label="Data")
plt.plot(x_range, y_pred, 'r--', label="Fitted k(x)")
plt.xlabel("EEG value")
plt.ylabel("Speed")
plt.title("Estimated k(x) using Polynomial Regression")
plt.legend()
plt.grid()
plt.show()

"""# new update

* first EEG value: set up speed for the first target
(initial standard velocity)
* while robot arm reaching the target: collect all of the EEG data and get average EEG
* average EEG value: use it for next movement toward second target
(with updated velocity)
==> smoother velocity

"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression

# ---------------------
# 로봇팔  robot arm len
L1 = 1.0
L2 = 1.0

# 목표점들 Goals (2 goal)
goals = [np.array([-1.5, 1]), np.array([1.5, -1.5])]

# EEG 입력 시퀀스
np.random.seed(42)
eeg = np.random.rand(100)  # 총 100 프레임
eeg_chunks = np.array_split(eeg, len(goals))  # 목표점 개수만큼 나눔

# 결과 저장 리스트
theta_list = []
ee_list = []
speed_list = []
eeg_list = []

# 초기 조건
dt = 0.05
theta = np.array([0.1, 0.1])

# 속도 게인 함수 정의 (예시)
def get_speed_gain_2nd(eeg_val):
    return 2 + 6 * eeg_val  # EEG 0~1 사이 값을 2~8 범위로 맵핑

# Forward Kinematics
def fk(t1, t2):
    p1 = np.array([L1 * np.cos(t1), L1 * np.sin(t1)])
    p2 = p1 + np.array([L2 * np.cos(t1 + t2), L2 * np.sin(t1 + t2)])
    return p1, p2

def inverse_kinematics(x, y, current_theta=None):
    # 거리 계산
    D = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)
    if np.abs(D) > 1.0:
        return current_theta  # 도달 불가한 경우 현재 각도 유지

    t2 = np.arctan2(np.sqrt(1 - D**2), D)  # elbow-down (or use -np.sqrt(...) for elbow-up)
    t1 = np.arctan2(y, x) - np.arctan2(L2 * np.sin(t2), L1 + L2 * np.cos(t2))

    return np.array([t1, t2])

# DS Velocity toward goal
def ds_velocity(x, goal):
    return goal - x

# 시뮬레이션 반복
for i, (goal, eeg_seq) in enumerate(zip(goals, eeg_chunks)):
    if i == 0:
        gain = 4.0  # 첫 타겟은 고정 속도 게인
    else:
        avg_eeg = np.mean(eeg_chunks[i - 1])  # 이전 EEG 평균값
        gain = get_speed_gain_2nd(avg_eeg)   # 평균값으로 속도 게인 설정

    for eeg_val in eeg_seq:
        p1, p2 = fk(theta[0], theta[1])
        x = p2
        v = ds_velocity(x, goal)
        v_mod = gain * v

        x_next = x + v_mod * dt
        theta = inverse_kinematics(x_next[0], x_next[1], theta)

        theta_list.append(theta.copy())
        ee_list.append(x.copy())
        speed_list.append(np.linalg.norm(v_mod))
        eeg_list.append(eeg_val)

# --------------------------
# 애니메이션 설정
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
ax1.set_xlim(-2, 2)
ax1.set_ylim(-2, 2)
ax1.set_aspect('equal')
ax1.set_title("EEG-Modulated Robot Arm to Two Goals")
for g in goals:
    ax1.plot(g[0], g[1], 'rx', markersize=10)

# 로봇 링크 및 궤적
link1, = ax1.plot([], [], 'bo-', lw=3)
link2, = ax1.plot([], [], 'go-', lw=3)
trail, = ax1.plot([], [], 'k--', alpha=0.3)
x_trail, y_trail = [], []

# 속도 및 EEG 플롯
ax2.set_xlim(0, len(speed_list))
ax2.set_ylim(0, max(speed_list) + 0.5)
ax2.set_title("EEG-based Speed and Input")
ax2.set_ylabel("Speed", color='r')
speed_line, = ax2.plot([], [], 'r-', label='Speed')

ax2_eeg = ax2.twinx()
ax2_eeg.set_ylim(0, 1.1)
ax2_eeg.set_ylabel("EEG input (s)", color='b')
eeg_line, = ax2_eeg.plot([], [], 'b--', label='EEG Input')

def animate(i):
    t1, t2 = theta_list[i]
    p1, p2 = fk(t1, t2)

    link1.set_data([0, p1[0]], [0, p1[1]])
    link2.set_data([p1[0], p2[0]], [p1[1], p2[1]])

    x_trail.append(p2[0])
    y_trail.append(p2[1])
    trail.set_data(x_trail, y_trail)

    speed_line.set_data(range(i+1), speed_list[:i+1])
    eeg_line.set_data(range(i+1), eeg_list[:i+1])

    return link1, link2, trail, speed_line, eeg_line

ani = animation.FuncAnimation(fig, animate, frames=len(theta_list), interval=70, blit=True)
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

# ---------------------
# 로봇팔  robot arm len
L1 = 1.0
L2 = 1.0

# 목표점들 Goals (2 goal)
goals = [np.array([-1.5, 1]), np.array([1.5, -1.5])]

# EEG 입력 시퀀스
np.random.seed(42)
eeg = np.random.rand(100)  # 총 100 프레임
eeg_chunks = np.array_split(eeg, len(goals))  # 목표점 개수만큼 나눔

# 결과 저장 리스트
theta_list = []
ee_list = []
speed_list = []
eeg_list = []

# 초기 조건
dt = 0.05
theta = np.array([0.1, 0.1])

# 속도 게인 함수 정의 (α(e) = α_min + e * (α_max - α_min))
def get_speed_gain_2nd(eeg_val, alpha_min=0.2, alpha_max=8.0):
    return alpha_min + eeg_val * (alpha_max - alpha_min)  # EEG 값을 이용해 속도 게인 계산

# Forward Kinematics
def fk(t1, t2):
    p1 = np.array([L1 * np.cos(t1), L1 * np.sin(t1)])
    p2 = p1 + np.array([L2 * np.cos(t1 + t2), L2 * np.sin(t1 + t2)])
    return p1, p2

def inverse_kinematics(x, y, current_theta=None):
    # 거리 계산
    D = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)
    if np.abs(D) > 1.0:
        return current_theta  # 도달 불가한 경우 현재 각도 유지

    t2 = np.arctan2(np.sqrt(1 - D**2), D)  # elbow-down (or use -np.sqrt(...) for elbow-up)
    t1 = np.arctan2(y, x) - np.arctan2(L2 * np.sin(t2), L1 + L2 * np.cos(t2))

    return np.array([t1, t2])

# DS Velocity toward goal
def ds_velocity(x, goal):
    return goal - x

# 시뮬레이션 반복
for i, (goal, eeg_seq) in enumerate(zip(goals, eeg_chunks)):
    if i == 0:
        gain = 3.0  # 첫 타겟은 고정 속도 게인
    else:
        avg_eeg = np.mean(eeg_chunks[i - 1])  # 이전 EEG 평균값
        gain = get_speed_gain_2nd(avg_eeg)   # 평균값으로 속도 게인 설정

    for eeg_val in eeg_seq:
        p1, p2 = fk(theta[0], theta[1])
        x = p2
        v = ds_velocity(x, goal)
        v_mod = gain * v

        x_next = x + v_mod * dt
        theta = inverse_kinematics(x_next[0], x_next[1], theta)

        theta_list.append(theta.copy())
        ee_list.append(x.copy())
        speed_list.append(np.linalg.norm(v_mod))
        eeg_list.append(eeg_val)

# --------------------------
# 애니메이션 설정
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
ax1.set_xlim(-2, 2)
ax1.set_ylim(-2, 2)
ax1.set_aspect('equal')
ax1.set_title("EEG-Modulated Robot Arm to Two Goals")
for g in goals:
    ax1.plot(g[0], g[1], 'rx', markersize=10)

# 로봇 링크 및 궤적
link1, = ax1.plot([], [], 'bo-', lw=3)
link2, = ax1.plot([], [], 'go-', lw=3)
trail, = ax1.plot([], [], 'k--', alpha=0.3)
x_trail, y_trail = [], []

# 속도 및 EEG 플롯
ax2.set_xlim(0, len(speed_list))
ax2.set_ylim(0, max(speed_list) + 0.5)
ax2.set_title("EEG-based Speed and Input")
ax2.set_ylabel("Speed", color='r')
speed_line, = ax2.plot([], [], 'r-', label='Speed')

ax2_eeg = ax2.twinx()
ax2_eeg.set_ylim(0, 1.1)
ax2_eeg.set_ylabel("EEG input (s)", color='b')
eeg_line, = ax2_eeg.plot([], [], 'b--', label='EEG Input')

def animate(i):
    t1, t2 = theta_list[i]
    p1, p2 = fk(t1, t2)

    link1.set_data([0, p1[0]], [0, p1[1]])
    link2.set_data([p1[0], p2[0]], [p1[1], p2[1]])

    x_trail.append(p2[0])
    y_trail.append(p2[1])
    trail.set_data(x_trail, y_trail)

    speed_line.set_data(range(i+1), speed_list[:i+1])
    eeg_line.set_data(range(i+1), eeg_list[:i+1])

    return link1, link2, trail, speed_line, eeg_line

ani = animation.FuncAnimation(fig, animate, frames=len(theta_list), interval=70, blit=True)
HTML(ani.to_jshtml())